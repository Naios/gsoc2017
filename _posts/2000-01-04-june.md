---
title: "June"
bg: myblack
color: mygrey
fa-icon: plug
---

## Phase I - June

At the beginning of the first phase, I focused on fixing the requirements of my project.

Due to this I discovered the need of a `spread` or `explode` helper function which could invoke a callable object with the content of a given tuple directly, while passing non tuple like types through. A detailed description of my research [can be found here](https://cdn.rawgit.com/Naios/hpx/proposal/research.pdf).

In the remaining time of the first phase, I implemented the synchronous mapping and traversal API `map_pack` and `traverse_pack`, which was submitted as part of pull request [#2704](https://github.com/STEllAR-GROUP/hpx/issues/2704).

A minimalistic example of a typical use case of this API might be the following, where we map all values to floats:

{% highlight cpp linenos=table %}
hpx::util::tuple<float, std::vector<float>,
                 hpx::util::tuple<float, float>> res =
map_pack([](int i) {
    return float(i);
}, 1, std::vector<int>{2, 3, 4}, hpx::util::make_tuple(5, 6));
{% endhighlight %}

The API fully supports all requirements mentioned above like arbitrarily nested containers
and move only types. Thus it's a real improvement over the previous internal code
of the `unwrapped` function.

Since the API isn't fixed on mapping `hpx::lcos::future` objects we can test it, with more generic unit tests. Also, we are able to test the mapping API and the future unwrap functionality independently from each other.

Additionally, the capability to test for compiler features directly with header only parts of HPX was added to CMake.
This is used to provide a generic feature test, that uses the `traverse_pack` API, which tests whether the currently used compiler is capable of full expression SFINAE support.
